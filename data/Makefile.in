# Autogenerated Makefile using "flit update"

FFLAGS          ?=
DEV_TARGET      ?= devrun
DEV_CUTARGET    ?= cu_devrun
GT_TARGET       ?= gtrun
GT_OUT          := ground-truth.csv

UNAME_S         := $(shell uname -s)

FLIT_INC_DIR    := {flit_include_dir}
FLIT_LIB_DIR    := {flit_lib_dir}
FLIT_DATA_DIR   := {flit_data_dir}
FLIT_SCRIPT_DIR := {flit_script_dir}

DEV_CC          ?= {dev_compiler}
DEV_OPTL        ?= {dev_optl}
DEV_SWITCHES    ?= {dev_switches}

GT_CC           := {ground_truth_compiler}
GT_OPTL         := {ground_truth_optl}
GT_SWITCHES     := {ground_truth_switches}

NVCC_BIN        := nvcc
NVCC            := $(shell which $(NVCC_BIN))
CUDA_DIR        := $(dir $(NVCC))/..

OBJ_DIR          = obj

CC_REQUIRED     += $(FFLAGS)
CC_REQUIRED     += -std=c++11
CC_REQUIRED     += -I.
CC_REQUIRED     += -I$(FLIT_INC_DIR)

DEV_CFLAGS      += -g
DEV_CFLAGS      += -Wall
DEV_CFLAGS      += -Wextra
DEV_CFLAGS      += -Wuninitialized
DEV_CFLAGS      += -Wno-shift-count-overflow

LD_REQUIRED     += -lm
LD_REQUIRED     += -lstdc++
ifeq ($(UNAME_S),Darwin) # If we are on a Mac OSX system
  LD_REQUIRED   += -Llib -lflit
else
  LD_REQUIRED   += -L$(FLIT_LIB_DIR) -lflit
  LD_REQUIRED   += -Wl,-rpath=$(realpath $(FLIT_LIB_DIR))
endif

DEV_LDFLAGS     +=

DEPFLAGS        += -MMD -MF $(patsubst %.o,%.d,$@)

TESTS            = $(wildcard tests/*.cpp)
SOURCE           = $(wildcard *.cpp)
SOURCE          += $(TESTS)

VPATH            = $(dir $(SOURCE))

CUSOURCE        += $(TESTS)
CUSOURCE        += $(wildcard *.cpp)
# TODO: use DEV_CUOBJ.  It is not yet used
DEV_CUOBJ       += $(addprefix $(OBJ_DIR)/,$(notdir $(CUSOURCE:%.cpp=%_cu_dev.o)))

VPATH           += $(dir $(CUSOURCE))

HAS_CUDA        := $(shell command -v $(NVCC_BIN) 2> /dev/null)
ifdef HAS_CUDA
NVCC_CFLAGS     += --std=c++11
NVCC_CFLAGS     += -ccbin=g++
NVCC_CFLAGS     += $(DEVCAP)
NVCC_CFLAGS     += -I .
NVCC_CFLAGS     += -x cu
NVCC_CFLAGS     += -dc
NVCC_CFLAGS     += -D__CUDA__
NVCC_CFLAGS     += -I$(FLIT_INC_DIR)
NVCC_CFLAGS     += -I$(CUDA_DIR)/samples/common/inc
endif # end of ifdef HAS_CUDA

ifeq ($(UNAME_S),Darwin) # If we are on a Mac OSX system
  NVCC_LINK     += -Llib -lflit
else  # not on Mac OSX
  NVCC_LINK     += -L$(FLIT_LIB_DIR) -lflit
  NVCC_LINK     += -Xcompiler \"-Wl,-rpath=$(realpath $(FLIT_LIB_DIR))\"
endif # end of if on Mac OSX

NVCC_LINK       += --std=c++11
NVCC_LINK       += -ccbin=g++
NVCC_LINK       += -L$(CUDA_DIR)/lib64

# TODO: double check CUDA flags.  Really?  No optimization levels?

DEV_NVCC_CC     +=
DEV_NVCC_LD     +=

.PHONY: help
help:
	@echo 'You can run the Makefile directly, but it is recommended to use'
	@echo
	@echo '  flit make'
	@echo
	@echo 'so that you can have functionality such as adding the results to a'
	@echo 'database.'
	@echo
	@echo 'The following targets are available:'
	@echo
	@echo '  help        Show this help and exit (default target)'
	@echo '  dev         Only run the devel compilation to test things out'
	@echo '  devcuda     Only run the devel CUDA compilation to test CUDA out'
	@echo '  groundtruth Compile the ground-truth version'
	@echo '  gt          Same as groundtruth'
	@echo '  runbuild    Build all executables needed for the run target'
	@echo '  run         Run all combinations of compilation, results in results/'
	@echo '  clean       Clean intermediate files'
	@echo '  veryclean   Runs clean + removes targets and results'
	@echo '  distclean   Same as veryclean'
	@echo

# Note: having this include at the end breaks the makefile for when users add
# to SOURCE from custom.mk
-include custom.mk

VPATH           := $(sort $(VPATH))


DEV_OBJ          = $(addprefix $(OBJ_DIR)/,$(notdir $(SOURCE:%.cpp=%_dev.o)))
DEV_DEPS         = $(DEV_OBJ:%.o=%.d)
GT_OBJ           = $(addprefix $(OBJ_DIR)/,$(notdir $(SOURCE:%.cpp=%_gt.o)))
GT_DEPS          = $(GT_OBJ:%.o=%.d)

CLANG           := clang++
INTEL           := icpc
GCC             := g++

ifndef CUDA_ONLY
COMPILERS       := $(foreach c, GCC INTEL CLANG, $(if $(shell which $($(c))), $c,))
endif

ifdef CLANG_ONLY
COMPILERS        = CLANG
endif

HOSTNAME        := $(shell hostname)

RESULTS_DIR     := results

# on systems with non-standard gcc installations (such as module), clang may
# be unable to determine the correct gcc toolchain
GCC_TOOLCHAIN   := $(dir $(shell which $(GCC)))/..
CLANG_REQUIRED  := --gcc-toolchain=$(GCC_TOOLCHAIN)

# Compiler setting targets
#   taken from: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html
#   among other places
# more comp settings, taken from here:
# https://software.intel.com/sites/default/files/article/326703/fp-control-2012-08.pdf

#individual flags
## optls

O0              := -O0
O1              := -O1
O2              := -O2
O3              := -O3

#switches

ASSOCMATH       := -fassociative-math
AVX             := -mavx
COMPTRANS       := -mp1
DEFFLAGS        :=
DISFMA          := -no-fma
ENAFMA          := -fma
FASTEXPREC      := -fexcess-precision=fast
FASTM           := -ffast-math
FINMATH         := -ffinite-math-only
FLUSHDEN        := -ftz
FMAGCC          := -mavx2 -mfma
FMAICC          := -march=core-avx2
FORTRULES       := -fcx-fortran-rules
FPCONT          := -ffp-contract=on
FPMODDBL        := -fp-model=double
FPMODEXC        := -fp-model=except
FPMODEXT        := -fp-model=extended
FPMODFST1       := -fp-model fast=1
FPMODFST2       := -fp-model fast=2
FPMODPRE        := -fp-model=precise
FPMODSRC        := -fp-model=source
FPMODSTR        := -fp-model=strict
FPTRAP          := -fp-trap=common
FSTORE          := -ffloat-store
LIMITEDRANGE    := -fcx-limited-range
MCONSTS         := -fmerge-all-constants
NOFLUSHDEN      := -no-ftz
NOPRECDIV       := -no-prec-div
NOTRAP          := -fno-trapping-math
PRECDIV         := -prec-div
RECIPMATH       := -freciprocal-math
ROUNDINGMATH    := -frounding-math
ROUNDUSR        := -fp-port
SIGNALNAN       := -fsignaling-nans
SINGLEPRECCONST := -fsingle-precision-constant
SSE             := -mfpmath=sse -mtune=native
STDEXPREC       := -fexcess-precision=standard
UNSOPTS         := -funsafe-math-optimizations
USEFASTM        := --use_fast_math

# Collections

OPCODES         := O0 O1 O2 O3

# NOTE: gcc disables ASSOCMATH @ O0
SWITCHES_GCC    += ASSOCMATH
SWITCHES_GCC    += AVX
SWITCHES_GCC    += DEFFLAGS
SWITCHES_GCC    += FASTEXPREC
SWITCHES_GCC    += FINMATH
SWITCHES_GCC    += FMAGCC
SWITCHES_GCC    += FORTRULES
SWITCHES_GCC    += FPCONT
SWITCHES_GCC    += FSTORE
SWITCHES_GCC    += LIMITEDRANGE
SWITCHES_GCC    += MCONSTS
SWITCHES_GCC    += NOTRAP
SWITCHES_GCC    += RECIPMATH
SWITCHES_GCC    += ROUNDINGMATH
SWITCHES_GCC    += SIGNALNAN
SWITCHES_GCC    += SSE
SWITCHES_GCC    += UNSOPTS

#NOTE: Clang not honoring ASSOCMATH (issues warning with 3.9)
# see: https://llvm.org/bugs/show_bug.cgi?id=27372

SWITCHES_CLANG  += ASSOCMATH
SWITCHES_CLANG  += AVX
SWITCHES_CLANG  += DEFFLAGS
SWITCHES_CLANG  += FASTEXPREC
SWITCHES_CLANG  += FINMATH
SWITCHES_CLANG  += FMAGCC
SWITCHES_CLANG  += FMAICC
SWITCHES_CLANG  += FPCONT
SWITCHES_CLANG  += FSTORE
SWITCHES_CLANG  += MCONSTS
SWITCHES_CLANG  += NOTRAP
SWITCHES_CLANG  += RECIPMATH
SWITCHES_CLANG  += ROUNDINGMATH
SWITCHES_CLANG  += SIGNALNAN
SWITCHES_CLANG  += SINGLEPRECCONST
SWITCHES_CLANG  += SSE
SWITCHES_CLANG  += STDEXPREC
SWITCHES_CLANG  += UNSOPTS

SWITCHES_INTEL  += AVX
SWITCHES_INTEL  += COMPTRANS
SWITCHES_INTEL  += DEFFLAGS
SWITCHES_INTEL  += DISFMA
SWITCHES_INTEL  += ENAFMA
SWITCHES_INTEL  += FLUSHDEN
SWITCHES_INTEL  += FMAGCC
SWITCHES_INTEL  += FMAICC
SWITCHES_INTEL  += FPMODDBL
SWITCHES_INTEL  += FPMODEXT
SWITCHES_INTEL  += FPMODFST1
SWITCHES_INTEL  += FPMODFST2
SWITCHES_INTEL  += FPMODPRE
SWITCHES_INTEL  += FPMODSRC
SWITCHES_INTEL  += FPMODSTR
SWITCHES_INTEL  += FSTORE
SWITCHES_INTEL  += LIMITEDRANGE
SWITCHES_INTEL  += MCONSTS
SWITCHES_INTEL  += NOFLUSHDEN
SWITCHES_INTEL  += NOPRECDIV
SWITCHES_INTEL  += PRECDIV
SWITCHES_INTEL  += ROUNDINGMATH
SWITCHES_INTEL  += ROUNDUSR
SWITCHES_INTEL  += SINGLEPRECCONST
SWITCHES_INTEL  += SSE
SWITCHES_INTEL  += USEFASTM

TARGET_OUTS     := $(foreach c, $(COMPILERS), \
                     $(foreach s, $(SWITCHES_$(strip $c)), \
                       $(foreach o, $(OPCODES), \
                         $(RESULTS_DIR)/$c_$(HOSTNAME)_$(strip $s)_$(strip $o)_out.csv \
                        ) \
                      ) \
                    )
TARGETS         := $(TARGET_OUTS:%_out.csv=%)
DEPS             = $(foreach b,$(TARGETS), \
                     $(addprefix $(OBJ_DIR)/,$(notdir $(SOURCE:%.cpp=%_$(notdir $b).d))) \
                    )
OBJ_CLEAN        = $(addprefix $(OBJ_DIR)/,$(notdir $(SOURCE:%.cpp=%_*.o)))
DEP_CLEAN       += $(OBJ_CLEAN:%.o=%.d)

##################################################
#
# Now deal with CUDA stuff if it is even available
#
##################################################



# These are the fp affecting switches for CUDA (7.5).
# We will naively apply these (though the docs say
# that, for instance, --use_fast_math implies
# --ftz=true --prec-div=false --prec-sqrt=false
# --fmad=true.

ifdef HAS_CUDA

FASTMC          := --use_fast_math
FMADFC          := --fmad=false
FMADTC          := --fmad=true
FTZFC           := --ftz=false
FTZTC           := --ftz=true
PRECDFC         := --prec-div=false
PRECDTC         := --prec-div=true
PRECSFC         := --prec-sqrt=false
PRECSTC         := --prec-sqrt=true

CUSWITCHES      += DEFFLAGS
CUSWITCHES      += FASTMC
CUSWITCHES      += FMADFC
CUSWITCHES      += FMADTC
CUSWITCHES      += FTZFC
CUSWITCHES      += FTZTC
CUSWITCHES      += PRECDFC
CUSWITCHES      += PRECDTC
CUSWITCHES      += PRECSFC
CUSWITCHES      += PRECSTC

CUTARGET_OUTS   := $(foreach s, $(CUSWITCHES), \
                     $(RESULTS_DIR)/NVCC_$(HOSTNAME)_$(strip $(s))_out.csv)
CUTARGETS       := $(CUTARGET_OUTS:%_out.csv=%)
CUDEPS           = $(foreach b,$(CUTARGETS), \
                     $(addprefix $(OBJ_DIR)/, \
                       $(notdir $(CUSOURCE:%.cpp=%_$(notdir $b).d))))

endif # ifdef HAS_CUDA

.PHONY: dev devcuda gt groundtruth run runbuild
dev: $(DEV_TARGET)
devcuda: $(DEV_CUTARGET)
gt: groundtruth
groundtruth: $(GT_TARGET)

run: $(TARGET_OUTS) $(CUTARGET_OUTS) runbuild $(GT_OUT)
runbuild: $(TARGETS) $(CUTARGETS) groundtruth

.PHONY: clean
clean:
	# Here we do it this way because we were running into the error of too many
	# arguments given to rm.
	$(foreach obj,$(OBJ_CLEAN),rm -f $(obj);)
	$(foreach obj,$(DEP_CLEAN),rm -f $(obj);)
	-rmdir $(OBJ_DIR)

.PHONY: veryclean distclean
veryclean: distclean
distclean: clean
	rm -f $(DEV_TARGET)
	rm -f $(DEV_CUTARGET)
	rm -f $(TARGET_OUTS)
	rm -f $(addsuffix *.dat,$(TARGET_OUTS))
	rm -f $(TARGETS)
	rm -f $(CUTARGET_OUTS)
	rm -f $(addsuffix *.dat,$(CUTARGET_OUTS))
	rm -f $(CUTARGETS)
	rm -f $(GT_TARGET)
	rm -f $(GT_OUT)
	rm -f $(addsuffix *.dat,$(GT_OUT))
	-rmdir $(RESULTS_DIR)

Makefile: flit-config.toml
Makefile: $(FLIT_DATA_DIR)/Makefile.in
Makefile: $(FLIT_SCRIPT_DIR)/flitconfig.py
Makefile: $(FLIT_SCRIPT_DIR)/flitutil.py
Makefile: $(FLIT_SCRIPT_DIR)/flit_update.py
	$(FLIT_SCRIPT_DIR)/flit.py update


# We have a different solution if we are on a mac
ifeq ($(UNAME_S),Darwin)
lib/libflit.so: $(FLIT_LIB_DIR)/libflit.so
	mkdir -p lib
	cp $< $@

.PHONY: cleanlibflit
distclean: cleanlibflit
cleanlibflit:
	rm -rf lib

$(DEV_TARGET): lib/libflit.so
$(GT_TARGET): lib/libflit.so
$(TARGETS): lib/libflit.so
$(CUTARGETS): lib/libflit.so
else
$(DEV_TARGET): $(FLIT_LIB_DIR)/libflit.so
$(GT_TARGET): $(FLIT_LIB_DIR)/libflit.so
$(TARGETS): $(FLIT_LIB_DIR)/libflit.so
$(CUTARGETS): $(FLIT_LIB_DIR)/libflit.so
endif # ifeq ($(UNAME_S),Darwin): meaning, we are on a mac


#
# Now for the compilation rules:
#

$(OBJ_DIR):
	mkdir -p $(OBJ_DIR)

# Dev compilation rules first (easier to understand)
$(DEV_TARGET): $(DEV_OBJ) Makefile custom.mk
	$(DEV_CC) $(CC_REQUIRED) $(DEV_CFLAGS) \
	  -o $@ $(DEV_OBJ) $(LD_REQUIRED) $(DEV_LDFLAGS)

$(OBJ_DIR)/%_dev.o: %.cpp Makefile custom.mk | $(OBJ_DIR)
	$(DEV_CC) $(DEV_OPTL) $(DEV_SWITCHES) $(CC_REQUIRED) $(DEV_CFLAGS) $(DEPFLAGS) -c $< -o $@ \
	  -DFLIT_HOST='"$(HOSTNAME)"'         \
	  -DFLIT_COMPILER='"$(DEV_CC)"'       \
	  -DFLIT_OPTL='"$(DEV_OPTL)"'         \
	  -DFLIT_SWITCHES='"$(DEV_SWITCHES)"' \
	  -DFLIT_FILENAME='"$(notdir $(DEV_TARGET))"'

ifdef HAS_CUDA
$(DEV_CUTARGET): $(DEV_CUOBJ) Makefile custom.mk
	$(NVCC) $(NVCC_LINK) $(DEV_NVCC_LD) $(DEV_CUOBJ) -o $(DEV_CUTARGET)

$(OBJ_DIR)/%_cu_dev.o: %.cpp Makefile custom.mk | $(OBJ_DIR)
	$(NVCC) -c $(NVCC_CFLAGS) $(DEV_NVCC_CC) $< -o $@
endif # ifdef HAS_CUDA

# Ground truth compilation rules
$(GT_OUT): $(GT_TARGET) $(TARGET_OUTS) $(CUTARGET_OUTS)
	./$(GT_TARGET) --output $(GT_OUT) \
	  --compare-mode $(TARGET_OUTS) $(CUTARGET_OUTS)

$(GT_TARGET): $(GT_OBJ) Makefile custom.mk
	$(GT_CC) $(CC_REQUIRED) -o $@ $(GT_OBJ) $(LD_REQUIRED)

$(OBJ_DIR)/%_gt.o: %.cpp Makefile custom.mk | $(OBJ_DIR)
	$(GT_CC) $(GT_OPTL) $(GT_SWITCHES) $(CC_REQUIRED) $(DEPFLAGS) -c $< -o $@ \
	  -DFLIT_HOST='"$(HOSTNAME)"'        \
	  -DFLIT_COMPILER='"$(GT_CC)"'       \
	  -DFLIT_OPTL='"$(GT_OPTL)"'         \
	  -DFLIT_SWITCHES='"$(GT_SWITCHES)"' \
	  -DFLIT_FILENAME='"$(notdir $(GT_TARGET))"'

# Now the true magic begins for the full run compilation rules
# very cool: recyclable target definitions! adapted from
# http://make.mad-scientist.net/the-eval-function/

# TODO: try without PERCENT variable
PERCENT         := %

# Generates rules for
#   1. compiling
#   2. running
#   3. replacing placeholders in output
# for a single target from TARGET_OUTS.
#
# @param $1: variable name containing compiler switch(es) for this compilation
#            (e.g. UNSOPTS for --funsafe-math-optimizations)
# @param $2: variable name containing the compiler to use (e.g. GCC)
# @param $3: variable name containing the optimization level (e.g. O2)
define TARGETS_RULE
# run test and collect results
$$(RESULTS_DIR)/$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3)_out.csv: \
  $$(RESULTS_DIR)/$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3)
	-./$$< --output $$@

# link
$$(RESULTS_DIR)/$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3) : \
  $$(addprefix $$(OBJ_DIR)/, \
     $$(notdir $$(SOURCE:$(PERCENT).cpp=$(PERCENT)_$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3).o)))
	mkdir -p $$(RESULTS_DIR)
	-$$($(strip $2)) $$($(strip $1)) $$($(strip $3)) $$($(strip $2)_REQUIRED) \
	$$(CC_REQUIRED) $$^ -o $$@ $$(LD_REQUIRED)

# TODO: set FLIT_COMPILER to the compiler name, not the executable used
# compile
$$(OBJ_DIR)/%_$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3).o: \
  %.cpp Makefile custom.mk | $$(OBJ_DIR)
	-$$($(strip $2)) -c $$($(strip $1)) $$($(strip $3)) $$(CC_REQUIRED) \
	   $$($(strip $2)_REQUIRED) $$< -o $$@                           \
	   $$(DEPFLAGS)                                                  \
	   -DFLIT_HOST='"$$(HOSTNAME)"'                                  \
	   -DFLIT_COMPILER='"$$($(strip $2))"'                           \
	   -DFLIT_OPTL='"$$($(strip $3))"'                               \
	   -DFLIT_SWITCHES='"$$($(strip $1))"'                           \
	   -DFLIT_FILENAME='"$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3)"'
endef
# end of define TARGETS_RULE

# Define individual rules for all elements of $(TARGET_OUTS)
$(foreach c, $(COMPILERS),                \
  $(foreach s, $(SWITCHES_$(strip $c)),   \
    $(foreach o, $(OPCODES),              \
      $(eval $(call TARGETS_RULE, $s, $c, $o)))))


# Generates rules for
#   1. compiling
#   2. running
#   3. replacing placeholders in output
# for a single target from CUTARGET_OUTS.
#
# @param $1: variable name containing compiler switch(es) for this compilation
#            (e.g. UNSOPTS for --funsafe-math-optimizations)
define CUTARGETS_RULE
#run test
NVCC_$$(HOSTNAME)_$(strip $1)_out.csv: NVCC_$$(HOSTNAME)_$(strip $1)
	./$$< --output $$@

#link test
NVCC_$$(HOSTNAME)_$(strip $1): \
  $$(addprefix $$(OBJ_DIR)/, \
     $$(notdir $$(CUSOURCE:$(PERCENT).cpp=$(PERCENT)_NVCC_$$(HOSTNAME)_$(strip $1).o)))
	$$(NVCC) $$($(strip $1)) $$(NVCC_LINK) $$^ -o $$@

#compile test
$(OBJ_DIR)/%_NVCC_$$(HOSTNAME)_$(strip $1).o : %.cpp Makefile custom.mk | $(OBJ_DIR)
	-$$(NVCC) -c $$($(strip $1)) $$(NVCC_CFLAGS) $$< -o $$@          \
	   $$(DEPFLAGS)                                                  \
	   -DFLIT_HOST='"$$(HOSTNAME)"'                                  \
	   -DFLIT_COMPILER='"$$(NVCC)"'                                  \
	   -DFLIT_OPTL='"$$($(strip $3))"'                               \
	   -DFLIT_SWITCHES='"$$($(strip $1))"'                           \
	   -DFLIT_FILENAME='"$$(strip $2)_$$(HOSTNAME)_$(strip $1)_$(strip $3)"'
endef
# end of def CUTARGETS_RULE

# define individual rules for all elements of $(CUTARGET_OUTS)
$(foreach s, $(CUSWITCHES), $(eval $(call CUTARGETS_RULE, $s)))

.PRECIOUS: %.d
-include $(DEPS) $(CUDEPS) $(DEV_DEPS) $(GT_DEPS)

