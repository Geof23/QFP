'Implements the import subcommand, importing results into a database'

import flitutil as util

import toml

import argparse
import csv
import datetime
import os
import sys

brief_description = 'Import flit results into the configured database'

def _file_check(filename):
    if not os.path.isfile(filename):
        raise argparse.ArgumentTypeError('File does not exist: {0}'.format(filename))
    return filename

def main(arguments, prog=sys.argv[0]):
    parser = argparse.ArgumentParser(
            prog=prog,
            description='''
                Import flit results into the configured database.  The
                configured database is found from the settings in
                flit-config.toml.  You can import either exported results or
                results from manually running the tests.
                ''',
            )
    parser.add_argument('importfile', nargs='+', type=_file_check,
                        help='''
                            File(s) to import into the database.  These files
                            may be csv files or sqlite3 databases.
                            ''')
    #parser.add_argument('-t', '--table', default='tests',
    #                    help='''
    #                        The database table used for import (default is tests)
    #                        ''')
    parser.add_argument('-r', '--run', type=int, default=-1,
                        help='''
                            The run number to import under.  If the run does
                            not exist in the runs table, then a new entry will
                            be created with an autogenerated message.  The
                            default behavior is to use the latest run in the
                            database (but one will be created if there is no
                            runs).  If importing from an sqlite database, the
                            run column of the tests table is ignored since
                            there is no necessary correlation between run
                            numbers of that database and this database.  So you
                            would still want to use the --run option.  For the
                            sqlite database case, the results imported will
                            only be from the latest run in the importing
                            database.
                            ''')
    parser.add_argument('--new-run', action='store_true',
                        help='''
                            Specifies that this import should be under a new
                            run number that will be autogenerated.  This option
                            conflicts with the --run option, meaning if this
                            argument is specified, then the --run argument will
                            be ignored.  This option is also implied if the
                            destination database has no runs in it.
                            ''')
    args = parser.parse_args(arguments)

    try:
        projconf = toml.load('flit-config.toml')
    except FileNotFoundError:
        print('Error: {0} not found.  Run "flit init"'.format(tomlfile),
              file=sys.stderr)
        return 1

    assert projconf['database']['type'] == 'sqlite', \
            'Only sqlite database supported'
    db = util.sqlite_open(projconf['database']['filepath'])

    # if the database has no runs, then turn on --new-run
    run_ids = [x['id'] for x in db.execute('select id from runs')]
    if len(run_ids) == 0:
        args.new_run = True

    # Find the destination run
    if not args.new_run:
        assert args.run <= 0 or args.run in run_ids, \
                'Specified run {0} is not in the runs table'.format(args.run)
        if args.run not in run_ids:
            args.run = sorted(run_ids)[-1]
    else: # args.new_run
        # Create a new run to use in import
        db.execute('insert into runs(rdate,notes) values (?,?)',
                (datetime.datetime.now(), 'Imported using flit import'))
        args.run = db.execute('select id from runs order by id').fetchall()[-1]['id']

    for importee in args.importfile:
        try:
            import_db = util.sqlite_open(importee)
            cur = import_db.cursor()
            cur.execute('select id from runs')
            run_ids = sorted([x['id'] for x in cur])
            assert len(run_ids) > 0
            latest_run = run_ids[-1]
            cur.execute('select name,host,compiler,optl,switches,precision,score,'
                               'score_d,resultfile,file,nanosec '
                        'from tests where run = ?', (latest_run,))
            rows = cur.fetchall()
        except:
            with open(importee, 'r') as csvin:
                reader = csv.DictReader(csvin)
                rows = [row for row in reader]
        to_insert = []
        for row in rows:
            to_insert.append((
                args.run,
                row['name'],
                row['host'],
                row['compiler'],
                row['optl'],
                row['switches'],
                row['precision'],
                row['score'] if row['score'] != 'NULL' else None,
                row['score_d'] if row['score_d'] != 'NULL' else None,
                row['resultfile'] if row['resultfile'] != 'NULL' else None,
                row['file'],
                row['nanosec'],
                ))
        db.executemany('''
            insert into tests(
                run,
                name,
                host,
                compiler,
                optl,
                switches,
                precision,
                score,
                score_d,
                resultfile,
                file,
                nanosec)
            values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', to_insert)
    db.commit()

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
