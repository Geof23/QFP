# FLiT Bisect Plan

The user adds custom build specifications to `custom.mk`.  This file should be
leveraged in the autogenerated Makefiles, as well as the customization in the
`flit-config.toml` file.

Here are the following design choices for accomplishing such a task:

1. compile using Python and skip Makefiles altogether
    - Too much work and not enough benefit.  Also unmaintainable
2. Generate a new `Makefile` similar to the already generated `Makefile`.  This
   could either be within the current directory or within `/tmp`.
3. Change the original generated `Makefile` to include an arbitrary `.mk` file
   based on a variable that is assigned in the call to `make`.
    - This approach seems more reasonable since the recursive `Makefile` change
      has been delivered, because we do not have any overhead until we are
      compiling a particular mode.

## Generate Source Files

The sources we need to compile will either be located in the autogenerated
`Makefile` (using the `$(wildcard)` GNU make function), or in `custom.mk`.  We
want the user to be able to specify additional source files in `custom.mk`, so
therefore, we need to query the `Makefile` for the list of source files.

There is a cool hack from [eric melski's blog](https://blog.melski.net/2010/11/30/makefile-hacks-print-the-value-of-any-variable/):

```make
print-%:
	@echo '$*=$($*)'
```

or the expanded version:

```make
print-%:
	@echo '$*=$($*)'
	@echo '  origin = $(origin $*)'
	@echo '  flavor = $(flavor $*)'
	@echo '   value = $(value $*)'
```

These rules can actually be placed in another `Makefile` and included separately

```bash
$ make -f printvar.mk -f Makefile print-SOURCE
```

## Identify the problem source file

Assuming that linking is not where the problem is introduced, but instead
during compilation, we can identify the problem source file.  This is done
using autogenerated Makefiles.  The algorithm is framed such that you have a
bag of eggs, and you can smell that there is at least one bad egg in the bag.
Given the ability to smell a bag, we want to smell as few times as possible to
identify all bad eggs.

The algorithm is described as follows.  You have some bags you can use during
the algorithm

1. **Test bag:** bag that we smell.  May have the bad egg we want to find
2. **Alternative bag:** bag that may have the bad egg we want to find
3. **Ignore bag:** could have bad eggs, but not the one we are looking for
4. **Bad bag:** where to put found bad eggs

In the simplest case, there is only one bad egg.  Let us cover that case first.

1. Put all eggs into the **test bag**.
2. If the **test bag** is empty, then return the **bad bag**
3. Smell the **test bag**.  If it does not smell bad, then swap the contents of
   the **test bag** and the **alternative bag**.
4. Place the eggs from the **alternative bag** into the **ignore bag**.
5. If the **test bag** only has one egg, then place it into the **bad bag**.
   Put all eggs from the **ignore bag** into the **test bag** to find the next
   bad egg.  Go to step 2
6. Put half of the eggs from the **test bag** into the **alternative bag**.
   Go to step 2

This algorithm actually has logic to find all bad eggs, one at a time.  Each
egg takes $O(\log n)$ time to find, which makes this algorithm $O(k \log n)$
time, where $k$ is the number of bad eggs and $n$ is the total number of eggs.

There is a slight optimization that can be done by adding one more bag called
**good bag**.  In step 3, instead of swapping the contents of the **test bag**
and the **alternative bag**, simply place the contents of the **test bag** into
the **good bag** and place the contents of the **alternative bag** into the
**test bag**.  This optimization makes subsequent passes not need to check
those that were already identified as good eggs.

## Identify interacting source files

However, the algorithm above does not work if you need more than one of the bad
eggs to be in the same bag for it to smell bad enough to detect.  Can we update
the algorithm to handle cases where more than one bad egg is needed in the same
bag to trigger a bad smell?

<span style="color: red">
TODO: try to come up with and test an algorithm for this.
</span>


## Find problem symbol

We want to be able to find the problem symbol within the set of bad files.
There are a few approaches to doing this.  Each has its advantages and
drawbacks.  All approaches are amenable to using the bisect approach.

1. Split the source code into two files
2. Use compiler-specific pragmas to disable optimizations
3. Use LLVM to disable optimizations for target function on the intermediate
   representation.
4. Mix and match the compiled symbols from the good and bad compilations


### Split source code

This approach has the advantage that it is straightforward when performed
manually.  Simply cut and paste functions from one file into the other and
compile and test.  It is easy to understand and easy to manually perform.

This approach has a few downsides:

1. Difficult to automate: requires C++ parsing, which is not simple
2. Need to deal with static functions, having a copy in each file
3. Having these functions split may influence inlining optimizations

<span style="color: red">
TODO: are there other optimizations this approach limits?
</span>


### Compiler-specific pragmas

A similar approach to this involves using pragmas in the code to disable
optimizations for particular functions.  This approach has an additional
drawback that it is not compiler agnostic, meaning we would need to do it
differently depending on the type of compiler we are using.


### LLVM disable optimizations

Instead of modifying the source code, we could tell the LLVM compiler to not
optimize specific functions that are represented in the LLVM intermediate
representation.

The benefits of this approach are that only the functions we do not want
optimized are not optimized.  This means that those functions that are
optimized can make use of inlining and everything else.  And we will be able to
target these function before optimization occurs.

The downsides are that it only works for LLVM, and it will take a long time to
develop an LLVM plugin.


### Mix and match compiled symbols

This approach has the advantage of allowing the compiler to optimize the same
way as it always has, but simply take the symbols we want after the fact.  That
should make this a more robust method.

This approach has a few downsides:

1. Very complex: difficult to get it to compile into something that can run
2. Inlining can give confusing results and either hide which function is
   actually to blame or return the wrong function entirely.
3. May not even be possible without writing my own tool.

<span style="color: red">
TODO: make tests that check this functionality with
TODO- (1) both shared,
TODO- (2) gt shared only,
TODO- (3) trouble shared only, and
TODO- (4) inlining.
</span>

I have actually found a way that works, but may have additional drawbacks.  Let
me describe first the approach that was able to correctly identify the dot
product within the `Vector` class in MFEM for `Example08`.

1. Recompile both the good object file and the bad object file with `-fPIC`
2. Create a list of all symbols in the bad object file:
   `nm <bad-obj-file>.o | cut -c19- > all-symbols.txt`
3. Split those symbols into the test set (`trouble-symbols.txt`) and the
   alternative set (`good-symbols.txt`)
4. Mark all symbols in the test set as local within the good object file:
   `objcopy --localize-symbols=trouble-symbols.txt <good-obj-file>.o <good-obj-file>-copy.o`
5. Only keep symbols in the test set as local within the bad object file:
   `objcopy --strip-all --keep-symbols=trouble-symbols.txt <bad-obj-file>.o <bad-obj-file>-copy.o`
6. Create a shared library with the one bad object file:
   `g++ -shared -o lib/lib<bad-obj-file>-copy.so obj/<bad-obj-file>-copy.o`
7. Create a shared library with the one good object file:
   `g++ -shared -o lib/lib<good-obj-file>-copy.so obj/<good-obj-file>-copy.o`
8. Link the shared libraries in the correct order
   `g++ <other-flags> -Llib -Wl,-rpath=$(pwd)/lib -l<good-obj-file> -l<bad-obj-file>`

This alternative approach has the downside of requiring `-fPIC` when compiling
the object files of interest.  This particular flag tells the compiler to
generate position-independent code.  This also has the byproduct that inlining
is disabled for all externally visible symbols, since the compiler cannot
ensure that certain functions won't get overridden with something like
`LD_PRELOAD`.

Quoted from Thiago Macieira [here](https://www.macieira.org/blog/2012/01/sorry-state-of-dynamic-libraries-on-linux/)

 > The `-fPIC` option doesn't enable only position-independent code. It also
 > enables ELF symbol interposition, which is when another module "steals" the
 > symbol. That happens normally by way of the copy relocations, but can also
 > happen if an `LD_PRELOAD`'ed module were to override those symbols. So the
 > compiler and linker must produce code that deals with that possibility.

It may be possible to compile in the trouble object file and then only link
against the good shared library, telling the linker to prefer symbols from the
shared library over those in the executable.  Or perhaps we could turn certain
symbols local and that would have the same effect.  This needs to be
investigated.

We also need to deal with relocation tables, which has a description found
[here](https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-54839.html).


